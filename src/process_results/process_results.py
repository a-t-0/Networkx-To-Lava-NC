"""Gets the run results from the MDSA SNN algorithm and from the default
Alipour algorithm."""
from src.helper import get_counter_neurons
from src.process_results.get_alipour_nodes import get_alipour_nodes


def get_run_results(G, G_mdsa, G_brain_adap, G_rad_dam, m, rand_props):
    """Takes in the original graph and mdsa, along with the brain adaptation
    and radiation damaged graphs (if they exist).

    Then computes which nodes the Alipour algorithm selects and compares
    that node selection with the node selection generated by the mdsa-,
    brain-adaptation- and radiation-damaged graphs respectively. Returns
    two lists, one with the lists for node selections, and another with
    the 3 boolean pass/fail values per SNN. The first list contains up
    to 4 lists of selected nodes for: the Alipour algorithm and the
    mdsa-, brain-adaptation- and radiation-damaged  SNN graphs
    respectively. The second list contains 3 booleans for the  mdsa-,
    brain-adaptation- and radiation-damaged SNN graphs respectively.

    :param G: The original graph on which the MDSA algorithm is ran.
    :param G_mdsa:
    :param G_brain_adap:
    :param G_rad_dam:
    :param m: The amount of approximation iterations used in the MDSA
     approximation.
    :param rand_props:
    """
    # pylint: disable=R0913
    # TODO: reduce from 6/5 to at most 5/5 arguments.

    # Compute the count for each node according to Alipour et al.'s algorithm.
    alipour_node_counts = get_alipour_nodes(
        G,
        m,
        rand_props,
    )

    mdsa_node_counts = get_nx_LIF_count(G, G_mdsa, m)
    brain_adap_node_counts = get_nx_LIF_count(G, G_brain_adap, m)
    rad_dam_node_counts = get_nx_LIF_count(G, G_rad_dam, m)

    results_equal_alipour = get_results(
        alipour_node_counts,
        mdsa_node_counts,
        brain_adap_node_counts,
        rad_dam_node_counts,
    )
    print(f"alipour_node_counts={alipour_node_counts}")
    print(f"mdsa_node_counts={mdsa_node_counts}")
    print(f"brain_adap_node_counts={brain_adap_node_counts}")
    print(f"rad_dam_node_counts={rad_dam_node_counts}")
    print(f"results_equal_alipour={results_equal_alipour}")
    return [
        alipour_node_counts,
        mdsa_node_counts,
        brain_adap_node_counts,
        rad_dam_node_counts,
    ], results_equal_alipour


def get_results(
    alipour_node_counts,
    mdsa_node_counts,
    brain_adap_node_counts,
    rad_dam_node_counts,
):
    """

    :param alipour_node_counts:
    :param mdsa_node_counts:
    :param brain_adap_node_counts:
    :param rad_dam_node_counts:

    """
    results_equal_alipour = lists_are_equal(
        [], alipour_node_counts, mdsa_node_counts, topic=None
    )
    results_equal_alipour = lists_are_equal(
        results_equal_alipour,
        alipour_node_counts,
        mdsa_node_counts,
        topic=None,
    )
    if brain_adap_node_counts is not None:
        results_equal_alipour = lists_are_equal(
            results_equal_alipour,
            alipour_node_counts,
            brain_adap_node_counts,
            topic=None,
        )
    if rad_dam_node_counts is not None:
        results_equal_alipour = lists_are_equal(
            results_equal_alipour,
            alipour_node_counts,
            rad_dam_node_counts,
            topic=None,
        )
    return results_equal_alipour


def lists_are_equal(results, left, right, topic=None):
    """

    :param results:
    :param left:
    :param right:
    :param topic:  (Default value = None)

    """
    if right is None:
        return results.append(None)
    if len(left) != len(right):
        raise Exception(
            "Error, the lists are not of equal length.\n "
            + f"left={left}\nright={right}\ntopic={topic}"
        )
    if left == right:
        results.append(True)
    else:
        results.append(False)
    return results


def get_nx_LIF_count(G, nx_SNN_G, m):
    """

    :param G: The original graph on which the MDSA algorithm is ran.
    :param nx_SNN_G:
    :param m: The amount of approximation iterations used in the MDSA
    approximation.

    """
    if nx_SNN_G is None:
        return None
    node_counts = []
    counter = 0
    counter_neurons = sorted(get_counter_neurons(nx_SNN_G))
    for nodename in counter_neurons:
        if nodename == f"counter_{counter}_{m}":
            node_counts.append(nx_SNN_G.nodes[nodename]["nx_LIF"].u.get())
            counter += 1
        else:
            raise Exception(
                "Counter node names and node indices are not in sync:counter="
                + f"{counter},nodename={nodename}"
            )
    if len(G) != len(node_counts):
        raise Exception("Insufficient node counts encountered.")
    return node_counts
